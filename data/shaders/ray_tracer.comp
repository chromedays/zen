#version 430 core
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct Sphere {
    vec3 c;
    float r;
};

struct View {
    vec3 eye;
    vec3 look;
    vec2 dims;
    float dist;
};

layout(std140) uniform Global {
    View view;
    Sphere spheres[100];
    int spheres_count;
} u_global;

float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}

struct RecContext {
    int i;
};

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    vec3 up = vec3(0, 1, 0);
    vec3 look = u_global.view.look;
    vec3 right = normalize(cross(look, up));
    up = normalize(cross(right, look));

    vec2 half_view_dims = u_global.view.dims * 0.5;
    ivec2 img_dims = imageSize(img_output);
    vec2 offset = vec2(pixel_coords * 2 - img_dims) / vec2(img_dims) * half_view_dims;

    vec3 ray_o = u_global.view.eye;
    vec3 ray_d = normalize(look * u_global.view.dist + right * offset.x + up * offset.y);

    vec4 pixel = vec4(0.3, 0, 0, 1);

    int bounce_count = 0;
    for (int a = 0; a < 3; ++a)
    {
        for (int i = 0; i < u_global.spheres_count; ++i)
        {
            Sphere sphere = u_global.spheres[i];
            float a = dot(ray_d, ray_d);
            float b = dot(ray_d, ray_o - sphere.c);
            float c = dot(ray_o - sphere.c, ray_o - sphere.c) - sphere.r * sphere.r;
            float d = b * b - a * c;

            if (d >= 0) {
                float t = (-b - sqrt(d)) / a;
                if (t > 0.1)
                {
                    vec3 p = ray_o + ray_d * t;
                    vec3 normal = (p - sphere.c) / sphere.r;
                    vec3 rand_v = normalize(vec3(
                        rand(vec2(normal.xy)),
                        rand(vec2(normal.yz)),
                        rand(vec2(normal.zx))
                        /*rand(vec2(0)),
                        rand(vec2(0)),
                        rand(vec2(0))*/
                    ));
                    ray_o = p;
                    ray_d = normalize(normal + rand_v);
                    //pixel = vec4(pixel.xyz * 0.5);
                    //pixel = vec4((normal.xyz + vec3(1)) * 0.5, 1);
                    ++bounce_count;
                    break;
                }
            }
        }
    }
    {
        float t = 0.5 * (ray_d.y + 1);
        pixel = vec4(((1 - t) * vec3(1) + t * vec3(0.5, 0.7, 1)).xyz, 1) * pow(0.5, bounce_count);
        //pixel = vec4(vec3(float(bounce_count) / 10).xyz, 1);
    }

    imageStore(img_output, pixel_coords, pixel);
}