#version 430 core
layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

struct Sphere {
    vec3 c;
    float r;
};

struct View {
    vec3 eye;
    vec3 look;
    vec2 dims;
    float dist;
};

layout(std140) uniform Global {
    View view;
    Sphere spheres[100];
    int spheres_count;
} u_global;

void main() {
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

    vec3 up = vec3(0, 1, 0);
    vec3 look = u_global.view.look;
    vec3 right = normalize(cross(look, up));
    up = normalize(cross(right, look));

    vec2 half_view_dims = u_global.view.dims * 0.5;
    ivec2 img_dims = imageSize(img_output);
    vec2 offset = vec2(pixel_coords * 2 - img_dims) / vec2(img_dims) * half_view_dims;

    vec3 ray_o = u_global.view.eye;
    vec3 ray_d = normalize(look * u_global.view.dist + right * offset.x + up * offset.y);

    vec4 pixel = vec4(0.3, 0, 0, 1);

    for (int i = 0; i < u_global.spheres_count; ++i)
    {
        Sphere sphere = u_global.spheres[i];
        float a = dot(ray_d, ray_d);
        float b = dot(ray_d, ray_o - sphere.c);
        float c = dot(ray_o - sphere.c, ray_o - sphere.c) - sphere.r * sphere.r;
        float d = b * b - a * c;

        if (d >= 0) {
            float t = (-b - sqrt(d)) / a;
            if (t >= 0)
            {
                vec3 p = ray_o + ray_d * t;
                vec3 normal = (p - sphere.c) / sphere.r;
                pixel = vec4((normal.xyz + vec3(1)) * 0.5, 1);
                break;
            }
        }
    }

    imageStore(img_output, pixel_coords, pixel);
}